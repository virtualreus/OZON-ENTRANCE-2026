# OZON Тестовое задание

Создание короткой ссылки на 10 символов по оригинальной и получение исходной ссылки по короткой.

## Настройка окружения

Скопировать .env.example подготовленный в .env корня проекта.

```bash
cp .env.example .env
```

Для выбора хранилища нужно задать true или false в переменной окружения IN_MEM, где false - использовать postgres, а true - использовать локальное in-memory хранилище.
По умолчанию postgres.

## Работа с сервисом

Все команды выполняются в корне проекта

### Запуск

```bash
make up
```

Принимает запросы по `http://localhost:8080` (либо другой порт заданный в .env).

### Остановка

```bash
make down
```

### Логи

```bash
make logs
```

### Unit тесты

```bash
make tests
```

## API

### Создать короткую ссылку

`POST /api/v0/link`

**Запрос:**

```json
{ "original": "https://ozon.ru/offer" }
```

**Ответ 200:**

```json
{ "short": "shortl1nk_" }
```

**Ошибки:** 400 (пустой или невалидный URL), 500 (ошибка сервера).

### Получить исходный URL

`GET /api/v0/link/{short}`

**Пример:** `GET /api/v0/link/shortl1nk_`

**Ответ 200:**

```json
{ "original": "https://ozon.ru/offer" }
```

**Ошибки:** 400 (невалидная короткая ссылка), 404 (ссылка не найдена), 500 (ошибка сервера).

Пример тела ошибки:

```json
{
  "error": {
    "message": "not found",
    "code": 404
  }
}
```

---

## Ответы на возможные вопросы (+ пояснения):

### 1) Почему именно такая валидация? Почему не использовал тот же validator.

Потому что в рамках проекта у нас достаточно мало проверок (корректность URL - встроенную функцию), а на короткую ссылку в целом проверка одного инварианта -> сложных структур в сервис не приходит, поэтому затаскивать ради двух маленьких проверок целый валидатор мне показалось оверхедом - он тут не нужен.

### 2) C чем связан выбор архитектуры?

Для такого кейса когда у нас в зависимости от переменной окружения выбирается реализация хранилища, архитектура подходит потому что юзкейсы не знают о том какое именно хранилище будет, поэтому выбор конкретного хранилища сводится к 2 дополнительным строчкам кода. И в целом архитектура гибкая, масштабируемая, переиспользуемая и удобно-тестируемая

### 3) Кеш - нужен ли?

В таких сервисах нагрузка на чтение кратко превосходит нагрузку на запись, поэтому можно сюда добавить кеш на чтение. Однако нужно продумать инвалидацию и его формат (ttl? lru?)

### 4) Нужен ли TTL для ссылок?

Все зависит от продукта и требований, так как ya.cc или vk.cc держит ссылки годами, поэтому тут нужно опираться на требования в зависимости от них масштабировать сервис.
Как вариант можно использовать TTL либо очищать ссылку если ей не пользовались n-ное время.
